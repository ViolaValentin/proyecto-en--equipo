Fundamentos de informÃ¡tica

Temas para el examen:
Todos los temas que estÃ¡n en Python intro: https://github.com/AJVelezRueda/Fundamentos_de_informatica/tree/master/Python_intro
Y ProgramaciÃ³n orientada a objetos â†’ Carpeta POO 
(https://github.com/AJVelezRueda/Fundamentos_de_informatica/tree/master/POO)
Pasar info de este docs: https://docs.google.com/document/d/1-ERGmC6hmNh7mo_4Sz2K_Z9Kqpq8pOmGd__KQqHnkoI/edit#heading=h.8lkqqrhx9wts
Clase 1 - teÃ³rica - 13/3
Profesor Titular: Dra. Ana Julia Velez 
E-mail: anavelezrueda@gmail.com

Profesor Ayudante: Lic. Guillermo Ignacio BenÃ­tez
E-mail: guillermo.benitez08@gmail.com

Links:

github.com/WomenBioinfoDataScla

flbulgarelli.github.io/recursos-python

www.github.com/Ajvelezrueda


Clase 2 - teorica - 20/3
Scrip es un archivo .py

Un script (en espaÃ±ol: guion) es bÃ¡sicamente un conjunto de instrucciones ordenadas, que buscan resolver una tarea especÃ­fica

Son Ãºtiles para automatizar tareas que se ejecutan periÃ³dicamente (tambiÃ©n conocidas como tareas programadas o calendarizadas) o automatizar situaciones tediosas 

Antes de correr el script hay que guardarlo (te das cuenta con el puntito blanci)

Son cÃ³digos de vÃ­a rÃ¡pida

Se ejecuta contra el intÃ©rprete de un lenguaje nuestro caso Phyton 

Comandos Ãºtiles: (se usan en la terminal )

ls: lista de archivos de un directorio 
cd: cambio de directorio â†’ej cd Documents/
pwd: muestra el path del directorio  en el que estoy
>>> eso te dice que estas en Python
Comandos basicos de Linux (https://ucema.edu.ar/webcampus3/pluginfile.php/173040/mod_resource/content/1/Comandos%20b%C3%A1sicos%20terminal%20Linux.pdf)

Buenas prÃ¡cticas para buscar archivos
NO poner nombres de archivos con espacio (ej: nombre_unacosa.py) (snake case)

Atajos Ãºtiles de de vsc:
ctr + s â†’ guardar 
ctr + j â†’ abrir/cerrar terminal 
ctr + d â†’ selector multiple
ctr + a â†’ selecciona todo
ctr + j â†’ ejecutar el cÃ³digo

Variable asignar un espacio a la memoria un tipo de dato, un pedazo de informaciÃ³n 

Es DISTINTO a un ARGUMENTO, debido a su alcance, estÃ¡ limitado a la funciÃ³n, no se guarda en la memoria 


ExtensiÃ³n define el lenguaje del lenguaje (.py)

Python tiene funciones built-in, por ej print
 
Bibliotecas: 

OS (operational system) es una librerÃ­a que sirve para manipular archivos, moverlos, DIALOGA con el sistema operativo, con la terminal.

os.listdir() â†’ nos permite hacer lista de archivos

SYS (system) tambiÃ©n dialoga y toma parÃ¡metros que le pasamos desde el script en la terminal

IMPORTANTE SABER MANEJAR ARCHIVOS

2 TIPOS DE ARCHIVOS para Python

El que puede ejecutar â†’ biblioteca os 
El que puede leer â†’ hay varias formas de leerlo 

Abrir archivos â†’ open(path_al_archivo, modo)

Apertura de archivos
Para abrir un archivo de texto, ya sea para usarlo o escribir en Ã©l, podemos usar la funciÃ³n nativa de Python open():
open(path_al_archivo, modo)
Donde:
- "path_al_archivo" es un objeto de tipo str que indica la ruta en la que se encuentra el archivo. 

- "modo" es un objeto de tipo str que indica la forma en la que Python accederÃ¡ al archivo en cuestiÃ³n.
PodÃ©s encontrar en la siguiente tabla algunos de los modos de lectura mÃ¡s frecuentes y sus diferencias:


Rutas/path:
Absolutas â†’ La ruta desde el directorio raÃ­z
Relativas â†’ Desde el directorio de trabajo â†’ ./Doc/hola.txt
La diferencia PRINCIPAL es que en un absoluto estÃ¡ el usuario de la computadora y si se lo pasas a alguien el cÃ³digo se rompe. USAR los relativos. 
Clase 3 - teÃ³rica - 27/3

NUNCA renombrar archivos con palabras reservadas o con nombres de librerÃ­as
with open sirve para abrir los archivos de forma segura y asÃ­ evitar tener que poner el close (por si nos olvidamos)
PATH â†’ es la ruta del archivo desde el directorio raÃ­z
Home/User =  ~
Control de Versiones
Es un software que nos va a permitir hacer un seguimiento de nuestros proyectos â†’ GitHub


Git pull â†’ Baja los cambios de un proyecto a mi computadora local. Siempre hay antes de arrancar hay que hacer un GIT PULL
Git add â†’ incorporar los cambios
Git commit â†’ sacar foto 
Registra â€œmetadataâ€ y todos los cambios del cÃ³digo
Se le debe asociar un mensaje â†’ git commit -m â€œmensaje que explique de quÃ© se trata ese msjâ€ 
Git push â†’ sube el proyecto/los cambios (depende el momento en el que estÃ© el cÃ³digo) a la web. Siempre antes de irme HAY QUE HACER UN GIT PUSH
Pasos para usar github:
usuario de github
vincular mi cuenta a mi computadora (clave ssh)
Git clone â†’ bajar un repositorio por 1ra vez 
Un repositorio es un directorio cualquiera que tiene toda la metadata/toda la info de mi proyecto 
Pasos:
git add .
git commit -m â€œadd exercisesâ€
git push
~ = home/user
Clonar 
Git 
Crear repo
Copiar ssh
Clonar
Poner los tps anteriores en la carpeta
En la terminal parado en la carpeta del repositorio que acabo de clonar 
Git add .
Git commit -m â€œadd exercisesâ€
Git push
Clase 2 - practica - 29/3
TeorÃ­a: https://github.com/AJVelezRueda/Fundamentos_de_informatica/blob/master/Python_intro/Practicas/Teor%C3%ADa_suplementaria.md
Rutas
movimiento de carpetas
 cd .. (ir una carpeta atrÃ¡s)
cd ../../  (ir dos carpeta atrÃ¡s)

Es para usarlo en PYTHON: 
os.mkdir(â€œrutaâ€) â†’ crear una carpeta en la ruta indicada (â€œ../escritorio/carreteâ€)
os.chdir (â€œrutaâ€) â†’ nos permite movernos de carpeta hasta la ruta indicada.

>> import os
>>> import glob
>>> os.listdir()  #te da solo los nombres del archivo
['Ej1.py', 'Ej3.py', 'archivo2.txt', 'Ej2.py', 'Ej4.py', 'documento.txt', 'Ej5.py'...]

>>> glob.glob("*")  # hace lo mismo que listdir (devuelve una lista con todos los archivos)
['Ej1.py', 'Ej3.py', 'archivo2.txt', 'Ej2.py', 'Ej4.py', 'documento.txt', 'Ej5.py'...]

>>> glob.glob("*.py")  #se puede poner parÃ¡metros, en este caso solo los archivos.py  
['Ej1.py', 'Ej3.py', 'Ej2.py', 'Ej4.py', 'Ej5.py'...]

Ejercicio de prÃ¡ctica
Escribir un script en el cual debemos movernos a la carpeta Informes y obtener los archivos *.txt que hayan allÃ­. Por cada archivo hay que obtener, por un lado, cuÃ¡ntas veces aparece la palabra "estado" y por otro lado la cantidad de lÃ­neas. Por Ãºltimo, hay que crear una carpeta que se llame Apellidos, donde hay que crear un archivo llamado Lista.txt que contenga en cada lÃ­nea la primer lÃ­nea de cada archivo .txt obtenidos anteriormente.


contador = 0 
for i in files:
if (i==â€Estadoâ€):
contador = contador + 1 


print contador
Clase 3 - practica - 31/3
Uso de git
#!/usr/bin/ env python3 â†’ es para que el intÃ©rprete entienda que el lenguaje va a ser python

IMPORTANTE: Siempre que creemos un repositorio hay que seleccionar la casilla de README
Copiar y pegar todos los archivos de la clase en el repositorio

Settings 
colaborators
anadir
BenitezG
AJVelezRueda

Para eliminar el archivo desde git se hace 
$ git rm nombre_del_archivo â†’ add â†’commitâ†’pull
Manejo de excepciones
(https://github.com/AJVelezRueda/Fundamentos_de_informatica/blob/master/Python_intro/Expresiones_regulares.md)

Manejo de errores

Errores de sintaxis â€”> TambiÃ©n conocidos como errores de interpretaciÃ³n (errores en la escritura del cÃ³digo) 

Excepciones â€”> Los errores detectados durante la ejecuciÃ³n
Ej: ZeroDivisionError, NameError, Type error 

>>> 3 / 0
      Traceback (most recent call last):
        File "<stdin>", line 1, in <module
      ZeroDivisionError: division by zero

Prever errores:
try:
          # aquÃ­ ponemos el cÃ³digo que puede lanzar excepciones 
      except:
          # entrarÃ¡ aquÃ­ en caso que se haya producido una excepciÃ³n 

Excepciones personalizadas â€”> raise
def check_int_type():
        if type(x)  != int:
          raise TypeError("Only integersâ€)


Clase 4 - teoria - 09/4 - Expresiones regulares
Phyton avanzado (https://github.com/AJVelezRueda/Fundamentos_de_informatica/blob/master/Python_intro/Manejo_excepciones.md)

* Los archivos que empiezan con punto estÃ¡n ocultos 
.gitignore â†’ para no subir ciertos archivos a github. Dentro de ese archivo escribir los nombres de los archivos o carpetas que no quiero subir.

Secuencias de escape:



Expresiones regulares â†’ son patrones de texto expresado en cÃ³digo. Son cadenas de caracteres basadas en reglas sintÃ¡cticas, que permiten describir secuencias de caracteres. 
Son una herramienta poderosa a la hora de hacer bÃºsquedas sofisticadas en Strings de forma simple.
Sirven para hacer bÃºsquedas muy especificas de texto o un patrÃ³n de texto 
Se usa para validaciÃ³n de cosas . Ej: Para saber si un email es vÃ¡lido o no, una tarjeta.

Es necesaria la librerÃ­a RE (regular expressions)

Metacaracteres â€”> Son caracteres especiales que, dependiendo del contexto, tienen un significado especial para las expresiones regulares.

Metacaracteres Delimitadores: nos permitirÃ¡n delimitar dÃ³nde queremos buscar los patrones de bÃºsqueda.


Metacaracteres cuantificadores:  permite repetir cierta cantidad de veces una bÃºsqueda dada

 {} â†’ cuantas veces tiene que aparecer ese patrÃ³n


Rangos â€”> son una clase de caracteres abreviada que se crea escribiendo el primer carÃ¡cter del rango, un guiÃ³n y el Ãºltimo carÃ¡cter del rango
El rango [a-d] equivale al [abcd]
El rango [aA-zZ] equivale a buscar desde la a a la z tanto mayus como minus.
El rango [1-10] equivale al substring [12345678910]
El rango [Dd] equivale a buscar una D mayÃºscula y una d minÃºscula

Podemos listar caracteres que no deben aparecer utilizando el ^. AsÃ­, por ejemplo, el rango [^a-d] coincide con cualquier carÃ¡cter que no sea abcd.

Coincidencias o matches 

>>> import re
>>> texto = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Amet et amet."
>>> patron = "amet"
>>> re.search/match(patron, texto) â†’ en el patrÃ³n puedo poner un string o un expresiÃ³n regular para eso le pongo una r antes.

La funciÃ³n match() busca el patrÃ³n y devuelve la primera apariciÃ³n y solo al principio de la cadena. Si se encuentra una coincidencia en la primera lÃ­nea, devuelve el objeto de coincidencia. Pero, si se encuentra una coincidencia en alguna otra lÃ­nea, devuelve un valor nulo.
Clase 4 - prÃ¡ctica - 12/4
bool (4) = True
bool (None) = False

Si el â€œpiquitoâ€ estÃ¡ dentro del rango estÃ¡ negando ese rango si estÃ¡ afuera es el inicio de lÃ­nea

Todos los patrones en Expresiones regulares son strings

Los metacaracteres solo afectan a las cosas que tengan a la izq

he* â†’ el * solo afecta a la e 
(he)* â†’ afecta a la h y a la e 

En E.R es importante entender las consignas 

(.*?) â†’ el signo de pregunta hace que sea mÃ¡s precisa la bÃºsqueda

La funciÃ³n split() sirve para: dividir una cadena de caracteres en una lista de cadenas mÃ¡s pequeÃ±as. Por defecto, split() divide la cadena en espacios en blanco y devuelve una lista con cada palabra en la cadena.

Clase 5 - teorÃ­a - 13/4 - POO
Paradigmas de programaciÃ³n - IntroducciÃ³n a la programaciÃ³n con objetos:
https://github.com/AJVelezRueda/Fundamentos_de_informatica/blob/master/POO/Teoria/Introducci%C3%B3n_a_POO.md

Paradigmas de ProgramaciÃ³n â†’ Es un conjunto de ideas que describe una forma de entender la construcciÃ³n de un programa. Estas ideas nos permiten pensar y estructurar el cÃ³digo de distintas forma.
Scripting â†’ programar de forma imperativa, dando ordenes

ProgramaciÃ³n orientada a objetos â†’ Es una forma de pensar los programas en la cual se estructura un programa construyendo piezas simples y reutilizables de cÃ³digo para crear instancias individuales de objetos.

Objetos y mensajes Un objeto es un ente computacional con el que podemos comunicarnos mediante mensajes y puede (o no) tener un estado interno (referencias a otros objetos). Pueden interactuar entre sÃ­
Las caracterÃ­sticas que lo hacen un objeto en particular son sus atributos. 

 Los objetos pueden tener estado, el cual puede cambiar a lo largo del tiempo. El estado es el conjunto de atributos de un objeto.  Cada vez que un objeto recibe un mensaje, hace algo, reaccionando al mismo. Por tanto, decimos que los objetos tienen un cierto comportamiento 
Ambiente â†’ Contexto en el que el viv en los objetos, tienen su estado y pueden entender mensajes. En un mismo ambiente podemos contar con varios objetos

Interfaz â†’ Conjunto de mensajes que cada objeto expone, puede ser (y tÃ­picamente serÃ¡) diferente para cada objeto.

Polimorfismo â†’ Objetos que comparten su interfaz son polimÃ³rficos. Puede ser parcial cuando comparten parte de su interfaz y cuando comparten todo son polimÃ³rficos. Para ver poliformismo se necesita un observador u otro actor.

Clases â†’ â€œmoldesâ€ que sirven para dar vida a objetos que se comporten de igual forma. Se ponen siempre con mayuscula

InstanciaciÃ³n â†’ Acto de crear un objeto a partir de una clase. Y a los objetos tambiÃ©n se los denomina instancias (de una clase particular). Por ejemplo, pepita es una instancia (de la clase Golondrina).Es un ej, un caso concreto/particular

Se escribe mediante la palabra reservada class, seguida de un nombre y :. Dentro de ella encontraremos los mÃ©todos, que son el cÃ³digo que especifica cÃ³mo se comportarÃ¡ un objeto cuando reciba un mensaje. Ej:
class Golondrina:
  def __init__(self, energia):
    self.energia = energia

MÃ©todos vs Funciones:
class Golondrina: #siempre en mayus el nombre de la clase
  def comer_alpiste(self, gramos):
    self.energia = self.energia + 4 * gramos
Las funciones se invocan como funciÃ³n(argumentos), pero los mÃ©todos se evalÃºan a travÃ©s el envÃ­o de mensajes como objeto.mensaje(argumentos)
Los mÃ©todos siempre declaran como primer parÃ¡metro self, las funciones no
Los mÃ©todos siempre van dentro de un clase, mientras que las funciones van por fuera
Un mÃ©todo es la descripciÃ³n de quÃ© hacer cuando se recibe un mensaje del mismo nombre. El conjunto de estos mÃ©todos provee de comportamiento a las instancias de una clase.

Tareas: Hacer que las golondrinas entiendan el mensaje esta_feliz(), y que devuelva si estÃ¡ feliz (que es cuando tienen de energÃ­a mÃ¡s de 50) y para los dragones, implementar ese mÃ©todo, pero estÃ¡n felices cuando tienen mÃ¡s de 500 de energÃ­a. Y el capÃ­tulo 1,2 y 3 de Mumuki (objetos)
Mumuki (POO):
Clase 1 
Dos referencias son idÃ©nticas si apuntan al mismo objeto y para saberlo contamos con el operador is, o =.
Las funciones retornan un valor mientras que los procedimientos tienen un efecto, es decir, modifican algo.
celular_de_eli.tiene_bateria_maxima()
False
 celular_de_eli.cargar_a_tope()
 celular_de_eli.tiene_bateria_maxima()
True
Clase 2
Los objetos tienen: una interfaz, es decir, el conjunto de mensajes que entiende; un estado, es decir, los atributos que posee.
Al programar con objetos cuando les enviamos mensajes, cada objeto le pregunta quÃ© hacer a su clase. Este concepto es conocido como method lookup, que en castellano serÃ­a algo asÃ­ como "bÃºsqueda del mÃ©todo"
Clase 3 
Excepciones: 
raise Exception('Este es el mensaje de la excepciÃ³n que estamos lanzando')
Para que dos mÃ©todos sean polimÃ³rficos no alcanza con que tengan el mismo nombre, tambiÃ©n necesitamos que tengan los mismos parÃ¡metros. Por eso a veces se fuerza


Clase 5 - prÃ¡ctica - 19/4 - POO
https://github.com/AJVelezRueda/Fundamentos_de_informatica/tree/master/POO/Practica

Es importante agregar modificadores a los rangos para que no solo busque caracteres sino â€œpalabrasâ€
[a-z] un caracter
[a-z]+ uno o mas caracteres
= â†’ asignar valor
== â†’ igualar


Polimorfismo: Cuando una clase puede mandar un mismo mensaje a distintos objetos. La clase que envÃ­a el mensaje debe ser una, y al menos 2 que lo reciban.

PREGUNTA DE EXÃMEN
Â¿QuÃ© es el polimorfismo?
Atributo â†’ Siempre van a tener el self adelante. Siempre se definen/construyen en el init. No son lo mismo que parÃ¡metros
Estado â†’ Conjunto de atributos
ParÃ¡metros â†’ son los que estÃ¡n incluidos entre parÃ©ntesis
Interfaz â†’ 
class Golondrina:
  def __init__(self, energia, altura):  #parÃ¡metros (energÃ­a, altura)self no cuenta conceptualmente como parÃ¡metro
    self.energia = energia #argumento (self.energÃ­a, self.altura)
    self.altura = 0
# el estado es self.energÃ­a y self.altura

Para que sean polimÃ³rficas 2 clases, necesito de una tercera que haga que las dos anteriores compartan un mensaje.


El __init__ es un constructor, un inicializador, no un mÃ©todo.
Los objetos tienen atributos y al conjunto de los mismos se los denomina estado. Los atributos tambiÃ©n son objetos y nos permiten guardar valores y representar caracterÃ­sticas del objeto que los posea.
__init__ viene de la palabra en inglÃ©s initialize que en castellano es inicializar. Es lo que se conoce como el constructor de una clase y nos permite darle valores iniciales a los atributos de sus instancias a la hora de crearlas. 
self es un primer parÃ¡metro obligatorio que nos permite acceder a los atributos del objeto que estamos instanciando. 
Un mÃ©todo es la descripciÃ³n de quÃ© hacer cuando se recibe un mensaje del mismo nombre. El conjunto de estos mÃ©todos provee de comportamiento a las instancias de una clase.
Clase 6 - teorÃ­a - 21/4 - POO - Herencia y Colecciones
Diferencia entre un mÃ©todo y un procedimiento. El mÃ©todo puede retornar o no valores. 

Las funciones retornan un valor mientras que los procedimientos tienen un efecto, es decir, modifican algo.
La herencia nos permite que las subclases (Condor y Halcon) posean los mismos mÃ©todos y atributos que la superclase Ave. Es decir, las instancias de Condor y de Halcon van a saber volar de la misma forma, pero cuando les enviemos el mensaje dormir cada una harÃ¡ algo diferente.
class Ave:
  def __init__(self, energia):
    self.energia = energia
  def volar(self):
    self.energia -= 20
class Condor(Ave):
  def dormir(self,minutos):
   self.energia += minutos * 3
class Halcon(Ave):
  def dormir(self,minutos):
   self.energia += minutos


2 Tipos de clases: Abstractas (no se instancian) y Concretas
Cuando dos o mÃ¡s objetos repiten lÃ³gica, creamos una clase con el comportamiento en comÃºn â†’  la llamaremos superclase. LlevarÃ¡ los mÃ©todos repetidos de las clases originales (subclases) y haremos que estas Ãºltimas hereden de ella. De esta forma, las subclases que heredan de la superclase sÃ³lo tendrÃ¡n definido su comportamiento particular. 
A este tipo de clases, como Dispositivo o Ave, se las llama clases abstractas porque, a diferencia de las clases concretas (como Tablet o Notebook), nunca las instanciamos. En otras palabras, no creamos objetos con esa clase, solo nos sirven para proveer comportamiento a sus subclases. 
Las superclases NO son objetos? 
A pesar de ello, una subclase puede heredar de una clase abstracta tanto como de una concreta.
Se redefinen los mÃ©todos cuando se heredan de una superclase pero queremos que actÃºen de otra forma
Usar super: cuando una subclase lo envÃ­a, se evalÃºa el mÃ©todo del mismo nombre de su superclase.
Las listas por comprensiÃ³n son una herramienta que nos permite hacer mapeos y/o filtrados sobre una lista. Por ejemplo, si quisiÃ©ramos obtener el doble de los nÃºmeros mayores a 5 de una lista nÃºmeros podrÃ­amos hacer:
[nÃºmero * 2 for numero in numeros if numero > 5]





Secuencia de escape	representaciÃ³n
\n	salto de lÃ­nea
\t	Tab o cambio de pestaÃ±a
\s	espacio
'	Comillas simples
"	Comillas dobles
2. Â¿QuÃ© son las expresiones regulares?
Las expresiones regulares son cadenas de caracteres basadas en reglas sintÃ¡cticas, que permiten describir secuencias de caracteres. Es decir es un criterio para buscar, capturar o reemplazar texto utilizando patrones. Estas son una herramienta poderosa a la hora de hacer bÃºsquedas sofisticadas en Strings de forma simple.

Las expresiones regulares se pueden concatenar para formar nuevas expresiones regulares; si, por ejemplo, A y B son expresiones regulares, AB tambiÃ©n es una expresiÃ³n regular.

Para pensar ğŸ¤”: Â¿QuÃ© usos crees que podemos darle a las expresiones regulares? ProponÃ© una aplicaciÃ³n concreta para tu carrera/disciplina.

3. Metacaracteres
Los metacaracteres son caracteres especiales que, dependiendo del contexto, tienen un significado especial para las expresiones regulares.

Existen lo que se conoce como metacaracteres delimitadores, que nos permitirÃ¡n delimitar dÃ³nde queremos buscar los patrones de bÃºsqueda. Entre ellos tenemos:

Metacaracter	Significado
^	Inicio de lÃ­nea
$	Fin de linea
\A	Inicio de texto
\Z	Fin de texto
.	Coincide con cualquier caracter en una lÃ­nea dada
Para pensar ğŸ¤”: Dado el siguiente texto:

texto = 'Esta es la linea uno\npalabra en la linea dos\n'
Â¿CÃ³mo crees que darÃ¡n las siguientes bÃºsquedas?

expresion regular a: '^palabra'

expresion regular b: '\Apalabra'

expresion regular c: 'palabra$'

expresion regular d: 'palabra\Z'

Ya vimos que en programaciÃ³n suele ser Ãºtil repetir la ejecuciÃ³n de porciones de cÃ³digo. Las expresiones regulares nos permiten no solo delimitar la porciÃ³n de texto donde deseamos buscar, sino que tambiÃ©n permite repitir cierta cantidad de veces una busqueda dada. Para ello se utilizan los metacaracteres cuantificadores:

Metacaracter	Significado
*	Cero o mÃ¡s: todas las ocurrencias de un dado substring
+	Una o mÃ¡s ocurrencias del patrÃ³n
?	Cero o una
{n}	Exactamente n veces
{n,m}	Por lo menos n pero no mÃ¡s de m veces.
Para pensar ğŸ¤”: Â¿QuÃ© significarÃ¡ la expresiÃ³n regular "X(.*)Y"? Ennumera algunas de las posibles strings que cumplen con dicha condiciÃ³n.

ğŸ§—â€â™€ï¸ DesafÃ­o I: Â¿ConstruÃ­ la expresiÃ³n regular que obtenga al menos 4 dÃ­gitos?

ğŸ§—â€â™€ï¸ DesafÃ­o II: Â¿ConstruÃ­ la expresiÃ³n regular que obtenga al entre 3 y 6 letras minÃºsculas?

ğŸ§—â€â™€ï¸ DesafÃ­o III: Â¿ConstruÃ­ la expresiÃ³n regular que obtenga todas las apariciones del patrÃ³n ab en un string?

Respuestas
Para pensar ğŸ¤”: Â¿Existe una Ãºnica respuesta para los ejercicios? Â¿QuÃ© otras alternativas se te ocurren?

Los dÃ­gitos entre llaves de la forma {n,m}, especifican el mÃ­nimo nÃºmero de ocurrencias en n y el mÃ¡ximo en m.

Existen tambien metacaracteres predefinidos, que nos facilitan el uso de las expresiones regulares:

Metacaracter	Significado
\w	Caracter alfanumÃ©rcio
\W	Caracter NO alfanumÃ©rcio
\d	Caracter numÃ©rcio
\D	Caracter NO numÃ©rcio
\s	Un espacio, de cualquier tipo (\t\n\r\f)
\S	Cualquier caracter que no sea un espacio
Como ya hemos visto, estos metacaracteres puden combinarse para lograr expresiones regulares complejas.

ğŸ§—â€â™€ï¸Desafio IV: Â¿QuÃ© expresiÃ³n regular usarÃ­as para extraer el nÃºmero de estudiantes que hay en una clase segÃºn el siguiente texto:

texto = 'En la clase de IntroducciÃ³n a la programaciÃ³n hay 30 estudiantes' 
Respuestas
Rangos

Un rango es una clase de caracteres abreviada que se crea escribiendo el primer caracter del rango, un guiÃ³n y el Ãºltimo caracter del rango. Sirve para listar un conjunto de caracteres de interÃ©s, de este modo se encontrarÃ¡ uno cualquiera de los caracteres de la lista. Por ejemplo:

- El rango [a-d] equivale al [abcd]
- El rango [1-10] equivale al substring [12345678910]
- El rango [Dd] equivale a buscar una D mayÃºscula y una d minÃºscula
AsÃ­ como podemos listar los caracteres posibles en cierta posiciÃ³n de la cadena, tambiÃ©n podemos listar caracteres que no deben aparecer utilizando el ^. AsÃ­, por ejemplo rango [^a-d] coincide con cualquier caracter que no sea abcd.

4. Expresiones regulares en Python
Para trabajar con expresiones regulares en Python, es necesaria la librerÃ­a RE, que puede ser instalada usando el instalador de Python (PIP):

pip install re
De todos modos, antes de instalar una librerÃ­a siempre es importante comprobar si esta estÃ¡ o no instalada. Para ello, desde una terminal de Python debemos escribir:

import re
Si la librerÃ­a estÃ¡ instalada no nos aparecerÃ¡ ningÃºn error.

5. Coincidencias o Matches
Comenzaremos por aprender sobre las expresiones regulares mÃ¡s simples posibles. Dado que las expresiones regulares se utilizan para operar en strings, vamos a empezas con la tarea mÃ¡s comÃºn: los caracteres coincidentes.

Si un String se corresponde con el criterio que define una expresiÃ³n regular, se dice que el String hace match con la expresiÃ³n, y equivalentemente, se dice que la expresiÃ³n acepta al String.

Podemos encontrar patrones en un texto con el funciÃ³n search:

>>> import re
>>> texto = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Amet et amet."
>>> patron = "amet"
>>> re.search(patron, texto)
Para pensar ğŸ¤”: Â¿QuÃ© resultado obtenemos al ejecutar en la Ãºltima linea?

ğŸ§—â€â™€ï¸Desafio V: imprimÃ­ el fragmento del texto entre la posiciÃ³n 22 y 26 Â¿QuÃ© resultado obtenÃ©s? Â¿QuÃ© quiere decir el mensaje span?

Ahora veamos quÃ© hace match():

>>> import re
>>> texto = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Amet et amet."
>>> patron = "amet"
>>> re.match(patron, texto)
Para pensar ğŸ¤”: Â¿QuÃ© resultado obtenemos con search()?Â¿QuÃ© diferencias observan con match()?

Detalles
Vamos a ejecutar la Ãºltima linea con una modificaciÃ³n:

>>> import re
>>> texto = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Amet et amet."
>>> patron = "amet"
>>> re.search(patron, texto).group()
Para pensar ğŸ¤”: Â¿QuÃ© resultado obtenemos? Â¿Para quÃ© sirve la funciÃ³n group()?

Utilicemos ahora otro mÃ©todo que nos permita obtener todas las ocurrencias del substring "amet"

>>> re.findall(patron, texto)
Para pensar ğŸ¤”: Â¿QuÃ© resultado obtenemos?

ğŸ§—â€â™€ï¸Desafio VI: ExpresÃ¡ el patron de bÃºsqueda utilizando lo visto anteriormente sobre metacaracteres y rangos.

Como vimos hasta acÃ¡ el mÃ©todo group() sirve para mostrar el resultado de una bÃºsqueda, pero veamos:

>>> import re
>>> texto = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Amet et amet."
>>> patron = "amet"
>>> re.search(patron, texto).group()
'amet'
>>> re.search(patron, texto).group(0)
'amet'
El mÃ©todo group() (o group(0)) nos devuelve la coincidencia. Sin embargo si lo que se quiere no es encontrar un patrÃ³n en particular, sino obtener lo que estÃ¡ dentro de cierto patrÃ³n (por ejemplo lo que hay entre ciertas palabras) hay que modificar el patrÃ³n. Vamos a ver el siguiente ejemplo:

>>> import re
>>> texto = "Lorem ipsum dolor sit amet, consectetur ipsum elit. Amet sit amet."
>>> patron = "ipsum(.*)sit"
>>> re.search(patron, texto).group()
'ipsum dolor sit amet, consectetur ipsum elit. Amet sit'
>>> re.search(patron, texto).group(0)
'ipsum dolor sit amet, consectetur ipsum elit. Amet sit'
>>> re.search(patron, texto).group(1)
' dolor sit amet, consectetur ipsum elit. Amet '
AcÃ¡ se utilizaron algunos metacaracteres, como lo son el punto (.) para indicar que puede ser cualquier carÃ¡cter, y el asterÃ­sco (*) para indicar que puede haber 0 o mÃ¡s de estos caracteres. De esta manera obtenemos como resultado lo que se encuentre entre las palabras "ipsum" y "sit", sin embargo observen dos cosas. Primero, el string que nos devuelve tiene dentro un substring que deberÃ­a haber sido encontrado en la bÃºsqueda: "ipsum dolor sit", pero que sin embargo no aparece. Segundo, nuevamente al hacer group() o group(0) obtenemos la coincidencia, pero si nos queremos quedar con el substring que estÃ¡ contenido entre estas palabras debemos utilizar group(1). Ahora bien, como vimos, usar el patrÃ³n de bÃºsqueda de esta manera prioriza los matches externos, es decir, busca el primer delimitador ("ipsum" en nuestro caso) y luego abarca todo hasta la Ãºltima apariciÃ³n del segundo delimitador ("sit"). Existe una forma de priorizar los matches internos y es con el metacarÃ¡cter ?:

>>> import re
>>> texto = "Lorem ipsum dolor sit amet, consectetur ipsum elit. Amet sit amet."
>>> patron = "ipsum(.*?)sit"
>>> re.search(patron, texto).group()
'ipsum dolor sit'
>>> re.search(patron, texto).group(0)
'ipsum dolor sit'
>>> re.search(patron, texto).group(1)
' dolor  '
Cuando se quieren obtener todas las apariciones del patrÃ³n se utiliza el mÃ©todo findall el cual actÃºa para cada coincidencia como si devolviera el group(1), es decir devuelve en una lista la parte que se encuentra dentro de los delimitadores.

>>> import re
>>> texto = "Lorem ipsum dolor sit amet, consectetur ipsum elit. Amet sit amet."
>>> patron = "ipsum(.*?)sit"
>>> re.findall(patron, texto)
[' dolor ', ' elit. Amet ']
6. Reemplazos o sustituciones masivas
Ejecutemos ahora la siguiente lÃ­nea:

>>> re.sub(patron, "###", texto)
Para pensar ğŸ¤”: Â¿QuÃ© resultado obtenemos? Â¿Para quÃ© sirve la funciÃ³n sub?

La funciÃ³n sub permite reemplazar todos las ocurrencias del patrÃ³n por otro patrÃ³n en un String.

